##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.41A/W32 EVALUATION    23/Apr/2009  14:43:30 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\ARM_proj\AT1315\I2CEEPROM.cpp                     #
#    Command line    =  C:\ARM_proj\AT1315\I2CEEPROM.cpp -lCN                #
#                       C:\ARM_proj\AT1315\Debug\List\ -o                    #
#                       C:\ARM_proj\AT1315\Debug\Obj\ -s6 --no_unroll        #
#                       --no_inline --no_tbaa --no_scheduling --debug        #
#                       --cpu_mode arm --endian little --cpu ARM7TDMI-S      #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config "C:\Program Files\IAR                  #
#                       Systems\Embedded Workbench 4.0                       #
#                       Evaluation\arm\LIB\dl4tpainl8n.h" -I "C:\Program     #
#                       Files\IAR Systems\Embedded Workbench 4.0             #
#                       Evaluation\arm\INC\"                                 #
#    List file       =  C:\ARM_proj\AT1315\Debug\List\I2CEEPROM.lst          #
#    Object file     =  C:\ARM_proj\AT1315\Debug\Obj\I2CEEPROM.r79           #
#                                                                            #
#                                                                            #
##############################################################################

C:\ARM_proj\AT1315\I2CEEPROM.cpp
      1          /*******************************************************************/
      2          /*    пп I2C - EEPROM        */
      3          /*******************************************************************/
      4          #include <iolpc2214.h>

   \                                 In segment DATA_AN, at 0xe01fc0c4
   \   union <unnamed> volatile __data _A_PCONP
   \                     _A_PCONP:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xfffff010
   \   union <unnamed> volatile __data _A_VICIntEnable
   \                     _A_VICIntEnable:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xfffff10c
   \   unsigned long volatile __data VICVectAddr3
   \                     VICVectAddr3:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xfffff20c
   \   union <unnamed> volatile __data _A_VICVectCntl3
   \                     _A_VICVectCntl3:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe002c000
   \   union <unnamed> volatile __data _A_PINSEL0
   \                     _A_PINSEL0:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c000
   \   union <unnamed> volatile __data _A_I2CONSET
   \                     _A_I2CONSET:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c004
   \   union <unnamed> const volatile __data _A_I2STAT
   \                     _A_I2STAT:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c008
   \   union <unnamed> volatile __data _A_I2DAT
   \                     _A_I2DAT:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c010
   \   union <unnamed> volatile __data _A_I2SCLH
   \                     _A_I2SCLH:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c014
   \   union <unnamed> volatile __data _A_I2SCLL
   \                     _A_I2SCLL:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0xe001c018
   \   union <unnamed> volatile __data _A_I2CONCLR
   \                     _A_I2CONCLR:
   \   00000000                      DS8 4
      5          #include <stdarg.h>
      6          #include "my_macros.h"
      7          
      8          #define I2CAddr  0x000000A0      //SLA адрес EEPROM
      9          /*bit Freq = (TARGED_BOARD_FREQ)/4/(I2SCLH+I2SCLL) =~ 330 KГц (263 для 14745)*/
     10          extern unsigned  short KODADC;
     11          extern unsigned  short KODADCEEPROM;
     12          extern unsigned  short MINPOROG;
     13          extern unsigned  short MAXPOROG;
     14          extern __BITFLAG FLAG;   //тип в macros
     15          extern unsigned char COMMAND[16];
     16          extern unsigned short CRChi,CRClo;
     17          extern void CRC16(unsigned char mas[],short usDataLen,char flFF,char flzapCOMMand);
     18          extern void toCOMMAND2byte(unsigned short nombyte,unsigned short datavalue);
     19          extern void DeInitialiseI2C(void);
     20          extern float TIMER0_INTERVAL;     //120000.0интервал в msek // каждые 2 минуты  - измерение температуры
     21          extern float TEMPERFLOAT;    //средняя текущая температура
     22          
     23          

   \                                 In segment DATA_Z, align 4, align-sorted
     24          unsigned char *I2CData,     //адрес массива данных для EEPROM
     25                         I2CCounter,  //кол-во байт данных
     26                         I2CAddress,  //SLA(CONTROL BYTE) адрес микросхемы EEPROM (у нас 1010 000r/w, 1-r,0-w)
     27                         MemAddress[2], //адрес байта в EEPROM
     28                         lock;        //флаг начала работы с I2C(EEPROM)
     29          unsigned char Flmembyte2;  //флаг пересылки 2-го байта адреса в EEPROM
     30          unsigned char FlerrRW;    //флаг кол-ва повторных обращений к EEPROM <5
     31          unsigned char MasEEPROMKoef[17];
     32          unsigned char TABLTemperCORR[126]; //ТАБЛИЦА ТЕМПЕР КОРРЕКЦИИ 61 знач по 2 байта +CRC 2б+ 1б флаг
   \                     TABLTemperCORR:
   \   00000000                      DS8 128
   \                     MasEEPROMKoef:
   \   00000080                      DS8 20
     33          void I2CInterruptW(void);
     34          void I2CInterruptR(void);
     35          unsigned char MasInt[6];
   \                     MasInt:
   \   00000094                      DS8 8
   \                     I2CData:
   \   0000009C                      DS8 4
   \                     MemAddress:
   \   000000A0                      DS8 2
   \                     I2CCounter:
   \   000000A2                      DS8 1
   \                     I2CAddress:
   \   000000A3                      DS8 1
   \                     lock:
   \   000000A4                      DS8 1
   \                     Flmembyte2:
   \   000000A5                      DS8 1
   \                     FlerrRW:
   \   000000A6                      DS8 1
     36          
     37          /******************************************************************************************
     38           * Initialise I2C bus used to access
     39           ****************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     40          void InitialiseI2C(unsigned char nn,unsigned char FlRead)
     41          /*nn=0 1-й вход при инициализации прибора,инициализация скорости, nn=1 последующие входы */
     42          /*FlRead = 0 вход при записи пп прерывания, FlRead=1 при чтении пп прерывания */
     43          {
   \                     InitialiseI2C:
   \   00000000   10002DE9           PUSH     {R4}
   \   00000004   ........           LDR      R2,??DataTable21  ;; TABLTemperCORR
     44          //   extern void handle_i2c(void);
     45             while (lock == 1) ;
   \                     ??InitialiseI2C_0:
   \   00000008   A430D2E5           LDRB     R3,[R2, #+164]
   \   0000000C   010053E3           CMP      R3,#+1
   \   00000010   FCFFFF0A           BEQ      ??InitialiseI2C_0
     46             lock       = 0;
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   A430C2E5           STRB     R3,[R2, #+164]
     47             PCONP =PCONP | 0x80;
   \   0000001C   A8C09FE5           LDR      R12,??InitialiseI2C_1  ;; 0xffffffffe01fc0c4
   \   00000020   00409CE5           LDR      R4,[R12, #+0]
   \   00000024   804084E3           ORR      R4,R4,#0x80
   \   00000028   00408CE5           STR      R4,[R12, #+0]
     48             PINSEL0   = (PINSEL0 & 0xFFFFFF0F) | 0x50;   /* enable I2C bus pins */
   \   0000002C   E0C4A0E3           MOV      R12,#-536870912
   \   00000030   B0CB8CE3           ORR      R12,R12,#0x2C000
   \   00000034   00409CE5           LDR      R4,[R12, #+0]
   \   00000038   F040C4E3           BIC      R4,R4,#0xF0
   \   0000003C   504084E3           ORR      R4,R4,#0x50
   \   00000040   00408CE5           STR      R4,[R12, #+0]
     49             if (nn == 0)
   \   00000044   EFC0E0E3           MVN      R12,#+239
   \   00000048   F0CECCE3           BIC      R12,R12,#0xF00
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0600001A           BNE      ??InitialiseI2C_2
     50                {
     51                  VICVectCntl3  = 0x29;    			/* vector I2C as highest priority and enabled */
   \   00000054   2900A0E3           MOV      R0,#+41
   \   00000058   FC018CE5           STR      R0,[R12, #+508]
     52                  I2SCLH    = 22;   //*увеличили частоту в 3 раза /* set I2C bus freq (330Khz)*/
   \   0000005C   6C009FE5           LDR      R0,??InitialiseI2C_1+0x4  ;; 0xffffffffe001c010
   \   00000060   1640A0E3           MOV      R4,#+22
   \   00000064   004080E5           STR      R4,[R0, #+0]
     53                  I2SCLL    = 38;    			        /**3 set I2C bus freq (330Khz)*/
   \   00000068   2640A0E3           MOV      R4,#+38
   \   0000006C   044080E5           STR      R4,[R0, #+4]
     54                }
     55             if (FlRead == 0)
   \                     ??InitialiseI2C_2:
   \   00000070   000051E3           CMP      R1,#+0
   \   00000074   0400001A           BNE      ??InitialiseI2C_3
     56                      {
     57                      VICVectAddr3  = (int) I2CInterruptW;	  	/* vector I2C interrupt address для записи*/
   \   00000078   54009FE5           LDR      R0,??InitialiseI2C_1+0x8  ;; I2CInterruptW
   \   0000007C   FC008CE5           STR      R0,[R12, #+252]
     58                      I2CAddress = I2CAddr;			//Place address and data in Globals to be used by the interrupt
   \   00000080   A000A0E3           MOV      R0,#+160
   \   00000084   A300C2E5           STRB     R0,[R2, #+163]
   \   00000088   030000EA           B        ??InitialiseI2C_4
     59                      }
     60              else
     61                      {
     62                      VICVectAddr3  = (int) I2CInterruptR;	  	/* vector I2C interrupt address для чтение*/
   \                     ??InitialiseI2C_3:
   \   0000008C   44009FE5           LDR      R0,??InitialiseI2C_1+0xC  ;; I2CInterruptR
   \   00000090   FC008CE5           STR      R0,[R12, #+252]
     63                      I2CAddress = I2CAddr | 1;			//Place address and data in Globals to be used by the interrupt
   \   00000094   A100A0E3           MOV      R0,#+161
   \   00000098   A300C2E5           STRB     R0,[R2, #+163]
     64                      }
     65             VICIntEnable =  VICIntEnable | 0x00000200; /*разрешение прерываний от I2C*/
   \                     ??InitialiseI2C_4:
   \   0000009C   00009CE5           LDR      R0,[R12, #+0]
   \   000000A0   800F80E3           ORR      R0,R0,#0x200
   \   000000A4   00008CE5           STR      R0,[R12, #+0]
     66             Flmembyte2 = 0;
   \   000000A8   A530C2E5           STRB     R3,[R2, #+165]
     67             FlerrRW    = 5;
   \   000000AC   0500A0E3           MOV      R0,#+5
   \   000000B0   A600C2E5           STRB     R0,[R2, #+166]
     68             FLAG.EEPROMAW =0;
     69             FLAG.EEPROMAR =0;
     70             FLAG.EEPROMDW =0;
     71             FLAG.EEPROMDR =0;
   \   000000B4   ........           LDR      R0,??DataTable38  ;; FLAG
   \   000000B8   001090E5           LDR      R1,[R0, #+0]
   \   000000BC   781DC1E3           BIC      R1,R1,#0x1E00
   \   000000C0   001080E5           STR      R1,[R0, #+0]
     72          }// end  InitialiseI2C
   \   000000C4   1000BDE8           POP      {R4}
   \   000000C8   1EFF2FE1           BX       LR               ;; return
   \                     ??InitialiseI2C_1:
   \   000000CC   C4C01FE0           DC32     0xffffffffe01fc0c4
   \   000000D0   10C001E0           DC32     0xffffffffe001c010
   \   000000D4   ........           DC32     I2CInterruptW
   \   000000D8   ........           DC32     I2CInterruptR
     73          /****************************************************************************/
     74          /* stop bit to I2C (EEPROM)*/
     75          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     76          void I2CStopBit (void)
     77          {
     78          I2CONSET=0x10; //_bit.STO = 1;         //Stop condition
   \                     I2CStopBit:
   \   00000000   E004A0E3           MOV      R0,#-536870912
   \   00000004   700B80E3           ORR      R0,R0,#0x1C000
   \   00000008   1010A0E3           MOV      R1,#+16
   \   0000000C   001080E5           STR      R1,[R0, #+0]
     79          Flmembyte2 = 0;
   \   00000010   ........           LDR      R0,??DataTable21  ;; TABLTemperCORR
   \   00000014   0010A0E3           MOV      R1,#+0
     80          lock = 0;
   \   00000018   B41AC0E1           STRH     R1,[R0, #+164]
     81          }// end I2CStopBit
   \   0000001C   1EFF2FE1           BX       LR               ;; return
     82          /****************************************************************************/
     83          /* Interrupt handler for I2C status change ЗАПИСЬ в EEPROM*/
     84          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     85          void I2CInterruptW(void)
     86          {
   \                     I2CInterruptW:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     87          	switch(I2STAT)
   \   00000004   ........           LDR      R0,??DataTable21  ;; TABLTemperCORR
   \   00000008   A310D0E5           LDRB     R1,[R0, #+163]
   \   0000000C   A620D0E5           LDRB     R2,[R0, #+166]
   \   00000010   013042E2           SUB      R3,R2,#+1
   \   00000014   A2C0D0E5           LDRB     R12,[R0, #+162]
   \   00000018   ........           LDR      R4,??DataTable38  ;; FLAG
   \   0000001C   005094E5           LDR      R5,[R4, #+0]
   \   00000020   4E62A0E3           MOV      R6,#-536870908
   \   00000024   706B86E3           ORR      R6,R6,#0x1C000
   \   00000028   00E096E5           LDR      LR,[R6, #+0]
   \   0000002C   08E05EE2           SUBS     LR,LR,#+8
   \   00000030   0800000A           BEQ      ??I2CInterruptW_0
   \   00000034   10E05EE2           SUBS     LR,LR,#+16
   \   00000038   0A00000A           BEQ      ??I2CInterruptW_1
   \   0000003C   08E05EE2           SUBS     LR,LR,#+8
   \   00000040   0B00000A           BEQ      ??I2CInterruptW_2
   \   00000044   08E05EE2           SUBS     LR,LR,#+8
   \   00000048   1200000A           BEQ      ??I2CInterruptW_3
   \   0000004C   08E05EE2           SUBS     LR,LR,#+8
   \   00000050   2300000A           BEQ      ??I2CInterruptW_4
   \   00000054   2F0000EA           B        ??I2CInterruptW_5
     88          	{
     89          	case 0x08:                  			 // a START condition has been transmitted
     90          		I2CONCLR=0x20;  //  _bit.STAC = 1;	 // Clear the START bit
   \                     ??I2CInterruptW_0:
   \   00000058   2000A0E3           MOV      R0,#+32
   \   0000005C   140086E5           STR      R0,[R6, #+20]
     91          		I2DAT = I2CAddress; 			 // Address and data direction
   \   00000060   041086E5           STR      R1,[R6, #+4]
   \   00000064   2C0000EA           B        ??I2CInterruptW_6
     92          		break;
     93          	case 0x18:		     			 // high SLA+W has been transmitted, ACK has been received
     94          		I2DAT = MemAddress[0]; 			 // Data to transmit.
   \                     ??I2CInterruptW_1:
   \   00000068   A000D0E5           LDRB     R0,[R0, #+160]
   \   0000006C   040086E5           STR      R0,[R6, #+4]
   \   00000070   290000EA           B        ??I2CInterruptW_6
     95          		break;
     96          	// ЗАПИСЬ В EEPROM
     97                  case 0x20:                  			 // SLA+W not ACK
     98          		  if (FlerrRW != 0)
   \                     ??I2CInterruptW_2:
   \   00000074   000052E3           CMP      R2,#+0
   \   00000078   0200000A           BEQ      ??I2CInterruptW_7
     99                              {
    100                              I2DAT = I2CAddress; 			 // Resend Address ????????
   \   0000007C   041086E5           STR      R1,[R6, #+4]
    101                              FlerrRW--;
   \   00000080   A630C0E5           STRB     R3,[R0, #+166]
   \   00000084   240000EA           B        ??I2CInterruptW_6
    102                              }
    103                            else
    104                                          {
    105                                          I2CStopBit();         //Stop condition
   \                     ??I2CInterruptW_7:
   \   00000088   ........           BL       I2CStopBit
    106                                          FLAG.EEPROMAW=1; //ФЛАГ ОШИБКИ ЗАПИСИ АДРЕСА В EEPROM
   \   0000008C   800F85E3           ORR      R0,R5,#0x200
   \   00000090   000084E5           STR      R0,[R4, #+0]
   \   00000094   200000EA           B        ??I2CInterruptW_6
    107                                          }
    108          		break;
    109                  case 0x28:                                        // Data sent,ACK
    110                          if (Flmembyte2 != 0)
   \                     ??I2CInterruptW_3:
   \   00000098   A510D0E5           LDRB     R1,[R0, #+165]
   \   0000009C   000051E3           CMP      R1,#+0
   \   000000A0   0A00000A           BEQ      ??I2CInterruptW_8
    111                          {
    112                              if (I2CCounter-- > 0)
   \   000000A4   01104CE2           SUB      R1,R12,#+1
   \   000000A8   A210C0E5           STRB     R1,[R0, #+162]
   \   000000AC   00005CE3           CMP      R12,#+0
   \   000000B0   0400000A           BEQ      ??I2CInterruptW_9
    113                              {
    114                                  I2DAT =*I2CData;                      // Write data
   \   000000B4   9C1090E5           LDR      R1,[R0, #+156]
   \   000000B8   ........           LDRB     R2,[R1], #+1
   \   000000BC   9C1080E5           STR      R1,[R0, #+156]
   \   000000C0   042086E5           STR      R2,[R6, #+4]
    115                                  I2CData++;
   \   000000C4   140000EA           B        ??I2CInterruptW_6
    116                              }
    117                              else
    118                                I2CStopBit();        //Stop condition
   \                     ??I2CInterruptW_9:
   \   000000C8   ........           BL       I2CStopBit
   \   000000CC   120000EA           B        ??I2CInterruptW_6
    119                          }
    120                          else
    121                          {
    122                           I2DAT = MemAddress[1];   //low 2-й байт адреса
   \                     ??I2CInterruptW_8:
   \   000000D0   A110D0E5           LDRB     R1,[R0, #+161]
   \   000000D4   041086E5           STR      R1,[R6, #+4]
    123                           Flmembyte2++;
   \   000000D8   0110A0E3           MOV      R1,#+1
   \   000000DC   A510C0E5           STRB     R1,[R0, #+165]
   \   000000E0   0D0000EA           B        ??I2CInterruptW_6
    124                          }
    125                          break;
    126                  case 0x30:                                       //Data send, Not ACK
    127                          if ((I2CCounter==0) || (FlerrRW == 0))
   \                     ??I2CInterruptW_4:
   \   000000E4   00005CE3           CMP      R12,#+0
   \   000000E8   0100000A           BEQ      ??I2CInterruptW_10
   \   000000EC   000052E3           CMP      R2,#+0
   \   000000F0   0300001A           BNE      ??I2CInterruptW_11
    128                                          {
    129                                          I2CStopBit();  //Stop condition
   \                     ??I2CInterruptW_10:
   \   000000F4   ........           BL       I2CStopBit
    130                                          FLAG.EEPROMDW=1; //ФЛАГ ОШИБКИ ЗАПИСИ ДАННЫХ В EEPROM
   \   000000F8   400E85E3           ORR      R0,R5,#0x400
   \   000000FC   000084E5           STR      R0,[R4, #+0]
   \   00000100   050000EA           B        ??I2CInterruptW_6
    131                                          }
    132                          else
    133                            {
    134                            I2DAT = *I2CData;                           //Write data - ????????
   \                     ??I2CInterruptW_11:
   \   00000104   9C1090E5           LDR      R1,[R0, #+156]
   \   00000108   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000010C   041086E5           STR      R1,[R6, #+4]
    135                            FlerrRW--;
   \   00000110   A630C0E5           STRB     R3,[R0, #+166]
   \   00000114   000000EA           B        ??I2CInterruptW_6
    136                            }
    137                          break;
    138          	default:
    139                          I2CStopBit();  //Stop condition
   \                     ??I2CInterruptW_5:
   \   00000118   ........           BL       I2CStopBit
    140          		break;
    141          	}//switch end
    142                  I2CONCLR=0x08; //_bit.SIC = 1;                  //Clear I2C interrapt
   \                     ??I2CInterruptW_6:
   \   0000011C   0800A0E3           MOV      R0,#+8
   \   00000120   140086E5           STR      R0,[R6, #+20]
    143          }// end I2CInterruptW
   \   00000124   7040BDE8           POP      {R4-R6,LR}
   \   00000128   1EFF2FE1           BX       LR               ;; return
    144          
    145          /****************************************************************************/
    146          /* Interrupt handler for I2C status change ЧТЕНИЕ ИЗ EEPROM*/
    147          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    148          void I2CInterruptR(void)
    149          {
   \                     I2CInterruptR:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    150          	switch(I2STAT)
   \   00000004   ........           LDR      R0,??DataTable21  ;; TABLTemperCORR
   \   00000008   9C1090E5           LDR      R1,[R0, #+156]
   \   0000000C   A620D0E5           LDRB     R2,[R0, #+166]
   \   00000010   A230D0E5           LDRB     R3,[R0, #+162]
   \   00000014   ........           LDR      R4,??DataTable38  ;; FLAG
   \   00000018   005094E5           LDR      R5,[R4, #+0]
   \   0000001C   E064A0E3           MOV      R6,#-536870912
   \   00000020   706B86E3           ORR      R6,R6,#0x1C000
   \   00000024   20C0A0E3           MOV      R12,#+32
   \   00000028   04E0A0E3           MOV      LR,#+4
   \   0000002C   047096E5           LDR      R7,[R6, #+4]
   \   00000030   087057E2           SUBS     R7,R7,#+8
   \   00000034   0800000A           BEQ      ??I2CInterruptR_0
   \   00000038   387057E2           SUBS     R7,R7,#+56
   \   0000003C   0A00000A           BEQ      ??I2CInterruptR_1
   \   00000040   087057E2           SUBS     R7,R7,#+8
   \   00000044   0A00000A           BEQ      ??I2CInterruptR_2
   \   00000048   087057E2           SUBS     R7,R7,#+8
   \   0000004C   1200000A           BEQ      ??I2CInterruptR_3
   \   00000050   087057E2           SUBS     R7,R7,#+8
   \   00000054   1E00000A           BEQ      ??I2CInterruptR_4
   \   00000058   1F0000EA           B        ??I2CInterruptR_5
    151          	{
    152          	case 0x08:                  			 // a START condition has been transmitted
    153          		I2CONCLR=0x20;  //  _bit.STAC = 1;	 // Clear the START bit
   \                     ??I2CInterruptR_0:
   \   0000005C   18C086E5           STR      R12,[R6, #+24]
    154          		I2DAT = I2CAddress; 			 // Address and data direction
   \   00000060   A300D0E5           LDRB     R0,[R0, #+163]
   \   00000064   080086E5           STR      R0,[R6, #+8]
   \   00000068   2B0000EA           B        ??I2CInterruptR_6
    155          		break;
    156                  // ЧТЕНИЕ ИЗ EEPROM
    157                  case 0x40:                   		// SLA+R has been transmitted,
    158          	        I2CONSET=0x04; //_bit.AA = 1;	// ACK has been received
   \                     ??I2CInterruptR_1:
   \   0000006C   00E086E5           STR      LR,[R6, #+0]
   \   00000070   290000EA           B        ??I2CInterruptR_6
    159          		break;
    160                  case 0x48:                   		// SLA+R not ACK,
    161                          if (FlerrRW !=0)
   \                     ??I2CInterruptR_2:
   \   00000074   000052E3           CMP      R2,#+0
   \   00000078   0300000A           BEQ      ??I2CInterruptR_7
    162                            {
    163          	          I2CONSET=0x20; //_bit.STA = 1;	        // resend start
   \   0000007C   00C086E5           STR      R12,[R6, #+0]
    164                            FlerrRW--;
   \   00000080   011042E2           SUB      R1,R2,#+1
   \   00000084   A610C0E5           STRB     R1,[R0, #+166]
   \   00000088   230000EA           B        ??I2CInterruptR_6
    165                            }
    166                          else
    167                          {
    168                            I2CStopBit();  //Stop condition
   \                     ??I2CInterruptR_7:
   \   0000008C   ........           BL       I2CStopBit
    169                            FLAG.EEPROMAR = 1;
   \   00000090   800E85E3           ORR      R0,R5,#0x800
   \   00000094   000084E5           STR      R0,[R4, #+0]
   \   00000098   1F0000EA           B        ??I2CInterruptR_6
    170                          }
    171          
    172          		break;
    173                  case 0x50:                                        // Data read,ACK
    174                          if (--I2CCounter > 0)
   \                     ??I2CInterruptR_3:
   \   0000009C   012043E2           SUB      R2,R3,#+1
   \   000000A0   A220C0E5           STRB     R2,[R0, #+162]
   \   000000A4   FF2012E2           ANDS     R2,R2,#0xFF
   \   000000A8   0500000A           BEQ      ??I2CInterruptR_8
    175                          {
    176                            *I2CData = I2DAT;                      // read data
   \   000000AC   082096E5           LDR      R2,[R6, #+8]
   \   000000B0   0020C1E5           STRB     R2,[R1, #+0]
    177                            I2CData++;
   \   000000B4   9C1090E5           LDR      R1,[R0, #+156]
   \   000000B8   011081E2           ADD      R1,R1,#+1
   \   000000BC   9C1080E5           STR      R1,[R0, #+156]
   \   000000C0   150000EA           B        ??I2CInterruptR_6
    178                         }
    179                          else
    180                          {
    181                            I2CONCLR=0x04;  //_bit.AA = 0;         //ПОСЛЕДНИЙ БАЙТ ЧИТАЕМ без посылки ACK
   \                     ??I2CInterruptR_8:
   \   000000C4   18E086E5           STR      LR,[R6, #+24]
    182                            *I2CData = I2DAT;
   \   000000C8   080096E5           LDR      R0,[R6, #+8]
   \   000000CC   0000C1E5           STRB     R0,[R1, #+0]
   \   000000D0   110000EA           B        ??I2CInterruptR_6
    183                          }
    184                          break;
    185          	case 0x58:				// Data  received, NOT ACK has not been returned
    186                          if (I2CCounter == 0)
   \                     ??I2CInterruptR_4:
   \   000000D4   000053E3           CMP      R3,#+0
   \   000000D8   0100001A           BNE      ??I2CInterruptR_9
    187                                I2CStopBit();        //Stop condition
   \                     ??I2CInterruptR_5:
   \   000000DC   ........           BL       I2CStopBit
   \   000000E0   0D0000EA           B        ??I2CInterruptR_6
    188                           else
    189                          {
    190                            if (FlerrRW !=0)
   \                     ??I2CInterruptR_9:
   \   000000E4   000052E3           CMP      R2,#+0
   \   000000E8   0800000A           BEQ      ??I2CInterruptR_10
    191                            {
    192                            *I2CData = I2DAT;                      // read data
   \   000000EC   082096E5           LDR      R2,[R6, #+8]
   \   000000F0   0020C1E5           STRB     R2,[R1, #+0]
    193                            I2CData++;
   \   000000F4   9C1090E5           LDR      R1,[R0, #+156]
   \   000000F8   011081E2           ADD      R1,R1,#+1
   \   000000FC   9C1080E5           STR      R1,[R0, #+156]
    194                            FlerrRW--;
   \   00000100   A610D0E5           LDRB     R1,[R0, #+166]
   \   00000104   011041E2           SUB      R1,R1,#+1
   \   00000108   A610C0E5           STRB     R1,[R0, #+166]
   \   0000010C   020000EA           B        ??I2CInterruptR_6
    195                            }
    196                            else
    197                            {
    198                            I2CStopBit();  //Stop condition
   \                     ??I2CInterruptR_10:
   \   00000110   ........           BL       I2CStopBit
    199                            FLAG.EEPROMDR =1;
   \   00000114   400D85E3           ORR      R0,R5,#0x1000
   \   00000118   000084E5           STR      R0,[R4, #+0]
    200                            }
    201                          }
    202                          break;
    203          	default:
    204                          I2CStopBit();  //Stop condition
    205          		break;
    206          	}//switch end
    207                  I2CONCLR=0x08; //_bit.SIC = 1;                  //Clear I2C interrapt
   \                     ??I2CInterruptR_6:
   \   0000011C   0800A0E3           MOV      R0,#+8
   \   00000120   180086E5           STR      R0,[R6, #+24]
    208          }// end I2CInterruptR
   \   00000124   F040BDE8           POP      {R4-R7,LR}
   \   00000128   1EFF2FE1           BX       LR               ;; return
    209          /****************************************************************************/
    210          /*Запуск транзакции на чтение / запись в EEPROM*/
    211          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    212          void I2CTransferByte(unsigned char MemAddr,unsigned char count,...)
    213          {//если count=0  устанавливается только адрес
   \                     I2CTransferByte:
   \   00000000   0C002DE9           PUSH     {R2,R3}
    214          va_list ap;
    215          va_start(ap,count);
   \   00000004   0D20A0E1           MOV      R2,SP
   \   00000008   ........           LDR      R3,??DataTable21  ;; TABLTemperCORR
    216          
    217          while(lock == 1)				//Wait for interrupt to signal end of I2C activity
   \                     ??I2CTransferByte_0:
   \   0000000C   A4C0D3E5           LDRB     R12,[R3, #+164]
   \   00000010   01005CE3           CMP      R12,#+1
   \   00000014   FCFFFF0A           BEQ      ??I2CTransferByte_0
    218          {
    219          ;
    220          }
    221          lock 	   = 1;                   		//Set I2C bus as active
   \   00000018   01C0A0E3           MOV      R12,#+1
   \   0000001C   A4C0C3E5           STRB     R12,[R3, #+164]
    222          Flmembyte2 = 0;
   \   00000020   00C0A0E3           MOV      R12,#+0
   \   00000024   A5C0C3E5           STRB     R12,[R3, #+165]
    223          if(count >0)
   \   00000028   000051E3           CMP      R1,#+0
   \   0000002C   0100000A           BEQ      ??I2CTransferByte_1
    224          {
    225          I2CData  	= va_arg(ap,unsigned char *);
   \   00000030   002092E5           LDR      R2,[R2, #+0]
   \   00000034   9C2083E5           STR      R2,[R3, #+156]
    226          }
    227          I2CCounter	= count;
   \                     ??I2CTransferByte_1:
   \   00000038   A210C3E5           STRB     R1,[R3, #+162]
    228          MemAddress[0]	= MemAddr >> 8; //ПЕРВЫМ ПЕРЕСЫЛАЕТСЯ СТ. БАЙТ АДРЕСА
   \   0000003C   A0C0C3E5           STRB     R12,[R3, #+160]
    229          MemAddress[1]	= MemAddr;
   \   00000040   A100C3E5           STRB     R0,[R3, #+161]
    230          I2CONCLR 	= 0x000000FF;			//Clear all I2C settings
   \   00000044   E004A0E3           MOV      R0,#-536870912
   \   00000048   700B80E3           ORR      R0,R0,#0x1C000
   \   0000004C   FF10A0E3           MOV      R1,#+255
   \   00000050   181080E5           STR      R1,[R0, #+24]
    231          I2CONSET 	= 0x00000004; 			//Enable ACK
   \   00000054   0410A0E3           MOV      R1,#+4
   \   00000058   001080E5           STR      R1,[R0, #+0]
    232          I2CONSET 	= 0x00000040; 			//Enable the I2C interface
   \   0000005C   4010A0E3           MOV      R1,#+64
   \   00000060   001080E5           STR      R1,[R0, #+0]
    233          I2CONSET 	= 0x00000020; 			//Start condition
   \   00000064   2010A0E3           MOV      R1,#+32
   \   00000068   001080E5           STR      R1,[R0, #+0]
    234          va_end(ap);
    235          }//end I2CTransferByte
   \   0000006C   08D08DE2           ADD      SP,SP,#+8
   \   00000070   1EFF2FE1           BX       LR               ;; return
    236          /****************************************************************************/
    237          /*ЗАПИСЬ МАССИВА КОЭФФИЦИЕНТОВ + CRC*/

   \                                 In segment CODE, align 4, keep-with-next
    238          void I2CMasKoefW_ (void)
    239          {
   \                     I2CMasKoefW_:
   \   00000000   10402DE9           PUSH     {R4,LR}
    240            CRC16(MasEEPROMKoef,15,0xFF,0);
   \   00000004   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   FF20A0E3           MOV      R2,#+255
   \   00000010   0F10A0E3           MOV      R1,#+15
   \   00000014   800084E2           ADD      R0,R4,#+128
   \   00000018   ........           _BLF     CRC16,??CRC16??rA
    241            MasEEPROMKoef[15] = CRClo;   //мл байт
   \   0000001C   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000020   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000024   8F00C4E5           STRB     R0,[R4, #+143]
    242            MasEEPROMKoef[16] = CRChi;  //cт байт
   \   00000028   ........           LDR      R0,??DataTable40  ;; CRChi
   \   0000002C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000030   9000C4E5           STRB     R0,[R4, #+144]
    243            InitialiseI2C(1,0); //инициализация для записи
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   ........           BL       InitialiseI2C
    244            I2CTransferByte(0,17,MasEEPROMKoef);
   \   00000040   802084E2           ADD      R2,R4,#+128
   \   00000044   1110A0E3           MOV      R1,#+17
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   ........           BL       I2CTransferByte
    245            while(lock == 1); //ждем
   \                     ??I2CMasKoefW__0:
   \   00000050   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   FCFFFF0A           BEQ      ??I2CMasKoefW__0
    246          }
   \   0000005C   1040BDE8           POP      {R4,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return
    247          /****************************************************************************/
    248          /*ЧТЕНИЕ МАССИВА КОЭФФИЦИЕНТОВ + CRC*/

   \                                 In segment CODE, align 4, keep-with-next
    249          void I2CMasKoefR_ (void)
    250          {
   \                     I2CMasKoefR_:
   \   00000000   10402DE9           PUSH     {R4,LR}
    251            InitialiseI2C(0,0); //инициализация 1-я для записи
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0100A0E1           MOV      R0,R1
   \   0000000C   ........           BL       InitialiseI2C
    252            I2CTransferByte(0,0);  //установка адреса данных 0
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   0100A0E1           MOV      R0,R1
   \   00000018   ........           BL       I2CTransferByte
    253            InitialiseI2C(1,1); //инициализация   для чтения
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   ........           BL       InitialiseI2C
    254            I2CTransferByte(0,17,MasEEPROMKoef);
   \   00000028   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
   \   0000002C   802084E2           ADD      R2,R4,#+128
   \   00000030   1110A0E3           MOV      R1,#+17
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   ........           BL       I2CTransferByte
    255            while(lock == 1); //ждем
   \                     ??I2CMasKoefR__0:
   \   0000003C   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000040   010050E3           CMP      R0,#+1
   \   00000044   FCFFFF0A           BEQ      ??I2CMasKoefR__0
    256          }
   \   00000048   1040BDE8           POP      {R4,LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    257          /****************************************************************************/
    258          /*Чтение интервала измерения температуры из EEPROM+CRC*/
    259          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    260          void I2CIntevarTemperR()
    261          {
   \                     I2CIntevarTemperR:
   \   00000000   10402DE9           PUSH     {R4,LR}
    262            InitialiseI2C(1,0); //инициализация  для записи
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   ........           BL       InitialiseI2C
    263            I2CTransferByte(17,0);  //установка адреса данных 17-я  запись
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   1100A0E3           MOV      R0,#+17
   \   00000018   ........           BL       I2CTransferByte
    264            InitialiseI2C(1,1); //инициализация   для чтения
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   ........           BL       InitialiseI2C
    265            I2CTransferByte(17,6,MasInt); //4байта плав интервал +CRC
   \   00000028   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
   \   0000002C   942084E2           ADD      R2,R4,#+148
   \   00000030   0610A0E3           MOV      R1,#+6
   \   00000034   1100A0E3           MOV      R0,#+17
   \   00000038   ........           BL       I2CTransferByte
    266            while(lock == 1); //ждем
   \                     ??I2CIntevarTemperR_0:
   \   0000003C   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000040   010050E3           CMP      R0,#+1
   \   00000044   FCFFFF0A           BEQ      ??I2CIntevarTemperR_0
    267          }// end 2CIntevarTemperR
   \   00000048   1040BDE8           POP      {R4,LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    268          /**************************************************************/
    269          /*запись полученного интервала в EEPROM, его контр чтение */
    270          /* С деинициализацией I2C*/
    271          /*************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    272          void I2CIntevarTemperW_(void)
    273          {
   \                     I2CIntevarTemperW_:
   \   00000000   10402DE9           PUSH     {R4,LR}
    274          int irab;
    275          CRC16(MasInt,4,0xFF,0);
   \   00000004   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   FF20A0E3           MOV      R2,#+255
   \   00000010   0410A0E3           MOV      R1,#+4
   \   00000014   940084E2           ADD      R0,R4,#+148
   \   00000018   ........           _BLF     CRC16,??CRC16??rA
    276          MasInt[4] = CRClo;   //мл байт
   \   0000001C   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000020   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000024   9800C4E5           STRB     R0,[R4, #+152]
    277          MasInt[5] = CRChi;  //cт байт
   \   00000028   ........           LDR      R0,??DataTable40  ;; CRChi
   \   0000002C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000030   9900C4E5           STRB     R0,[R4, #+153]
    278          
    279          InitialiseI2C(1,0); //инициализация для записи
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   ........           BL       InitialiseI2C
    280          I2CTransferByte(17,6,MasInt); //запись коэффиц
   \   00000040   942084E2           ADD      R2,R4,#+148
   \   00000044   0610A0E3           MOV      R1,#+6
   \   00000048   1100A0E3           MOV      R0,#+17
   \   0000004C   ........           BL       I2CTransferByte
    281          
    282          while (lock == 1); //пока не записали нельзя считать CRC
   \                     ??I2CIntevarTemperW__0:
   \   00000050   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   FCFFFF0A           BEQ      ??I2CIntevarTemperW__0
    283          
    284          DELAYTACKT(irab,100006);
   \   0000005C   ........           LDR      R0,??DataTable29  ;; 0x186a6
   \                     ??I2CIntevarTemperW__1:
   \   00000060   010050E2           SUBS     R0,R0,#+1
   \   00000064   FDFFFF5A           BPL      ??I2CIntevarTemperW__1
    285          
    286          I2CIntevarTemperR();
   \   00000068   ........           BL       I2CIntevarTemperR
    287          while (lock == 1); //пока не записали
   \                     ??I2CIntevarTemperW__2:
   \   0000006C   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000070   010050E3           CMP      R0,#+1
   \   00000074   FCFFFF0A           BEQ      ??I2CIntevarTemperW__2
    288          }//end 2CIntevarTemperW
   \   00000078   1040BDE8           POP      {R4,LR}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    289          /*********************************************************/
    290          /****************************************************************************/
    291          /*Чтение интервала измерения температуры из EEPROM,если не совпадает CRC запись в EEPROM*/
    292          /*значения по умолчанию = 2 минутам*/
    293          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    294          void ReadEEPROMIntervalTemper_(void)
    295          {
   \                     ReadEEPROMIntervalTemper_:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    296            int irab;
    297            float Inter2min;
    298          
    299            I2CIntevarTemperR(); /*чтение интервала*/
   \   00000008   ........           BL       I2CIntevarTemperR
   \   0000000C   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
    300            while (lock == 1); //пока не записали нельзя считать CRC
   \                     ??ReadEEPROMIntervalTemper__0:
   \   00000010   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000014   010050E3           CMP      R0,#+1
   \   00000018   FCFFFF0A           BEQ      ??ReadEEPROMIntervalTemper__0
    301            CRC16(MasInt,4,0xFF,0);
   \   0000001C   0030A0E3           MOV      R3,#+0
   \   00000020   FF20A0E3           MOV      R2,#+255
   \   00000024   0410A0E3           MOV      R1,#+4
   \   00000028   940084E2           ADD      R0,R4,#+148
   \   0000002C   ........           _BLF     CRC16,??CRC16??rA
    302            if( (CRClo != MasInt[4]) || (CRChi != MasInt[5]) )
   \   00000030   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000034   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000038   9810D4E5           LDRB     R1,[R4, #+152]
   \   0000003C   010050E1           CMP      R0,R1
   \   00000040   0400001A           BNE      ??ReadEEPROMIntervalTemper__1
   \   00000044   ........           LDR      R0,??DataTable40  ;; CRChi
   \   00000048   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000004C   9910D4E5           LDRB     R1,[R4, #+153]
   \   00000050   010050E1           CMP      R0,R1
   \   00000054   1000000A           BEQ      ??ReadEEPROMIntervalTemper__2
    303            {
    304             Inter2min = 2.0;
   \                     ??ReadEEPROMIntervalTemper__1:
   \   00000058   4014A0E3           MOV      R1,#+1073741824
   \   0000005C   00108DE5           STR      R1,[SP, #+0]
    305             MasInt[0] =  *(unsigned char*) & Inter2min; //мл байт
   \   00000060   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000064   9400C4E5           STRB     R0,[R4, #+148]
    306             MasInt[1] =  *((unsigned char*) & Inter2min+1);
   \   00000068   0100DDE5           LDRB     R0,[SP, #+1]
   \   0000006C   9500C4E5           STRB     R0,[R4, #+149]
    307             MasInt[2] =  *((unsigned char*) & Inter2min+2);
   \   00000070   0200DDE5           LDRB     R0,[SP, #+2]
   \   00000074   9600C4E5           STRB     R0,[R4, #+150]
    308             MasInt[3] =  *((unsigned char*) & Inter2min+3);
   \   00000078   0300DDE5           LDRB     R0,[SP, #+3]
   \   0000007C   9700C4E5           STRB     R0,[R4, #+151]
    309             DELAYTACKT(irab,100006);
   \   00000080   ........           LDR      R0,??DataTable29  ;; 0x186a6
   \                     ??ReadEEPROMIntervalTemper__3:
   \   00000084   010050E2           SUBS     R0,R0,#+1
   \   00000088   FDFFFF5A           BPL      ??ReadEEPROMIntervalTemper__3
    310             I2CIntevarTemperW_(); /*запись интервала = 2 минутам с CRC*/
   \   0000008C   ........           BL       I2CIntevarTemperW_
    311             while (lock == 1); //пока не записали нельзя считать CRC
   \                     ??ReadEEPROMIntervalTemper__4:
   \   00000090   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000094   010050E3           CMP      R0,#+1
   \   00000098   FCFFFF0A           BEQ      ??ReadEEPROMIntervalTemper__4
    312           }
    313          * (unsigned char*) & Inter2min   = MasInt[0];
   \                     ??ReadEEPROMIntervalTemper__2:
   \   0000009C   9410D4E5           LDRB     R1,[R4, #+148]
   \   000000A0   0010CDE5           STRB     R1,[SP, #+0]
    314          *((unsigned char*) & Inter2min+1)= MasInt[1];
   \   000000A4   9510D4E5           LDRB     R1,[R4, #+149]
   \   000000A8   0110CDE5           STRB     R1,[SP, #+1]
    315          *((unsigned char*) & Inter2min+2)= MasInt[2] ;
   \   000000AC   9610D4E5           LDRB     R1,[R4, #+150]
   \   000000B0   0210CDE5           STRB     R1,[SP, #+2]
    316          *((unsigned char*) & Inter2min+3)= MasInt[3];
   \   000000B4   9710D4E5           LDRB     R1,[R4, #+151]
   \   000000B8   0310CDE5           STRB     R1,[SP, #+3]
    317          TIMER0_INTERVAL=Inter2min * 60.0 * 1000.0;     //интервал в msek
   \   000000BC   34409FE5           LDR      R4,??ReadEEPROMIntervalTemper__5  ;; TIMER0_INTERVAL
   \   000000C0   00009DE5           LDR      R0,[SP, #+0]
   \   000000C4   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   000000C8   0020A0E3           MOV      R2,#+0
   \   000000CC   4034A0E3           MOV      R3,#+1073741824
   \   000000D0   4E3883E3           ORR      R3,R3,#0x4E0000
   \   000000D4   ........           _BLF     __dMul,??__dMul??rA
   \   000000D8   0020A0E3           MOV      R2,#+0
   \   000000DC   18309FE5           LDR      R3,??ReadEEPROMIntervalTemper__5+0x4  ;; 0x408f4000
   \   000000E0   ........           _BLF     __dMul,??__dMul??rA
   \   000000E4   ........           _BLF     __doubleToFloat,??__doubleToFloat??rA
   \   000000E8   000084E5           STR      R0,[R4, #+0]
    318          }
   \   000000EC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000F0   1040BDE8           POP      {R4,LR}
   \   000000F4   1EFF2FE1           BX       LR               ;; return
   \                     ??ReadEEPROMIntervalTemper__5:
   \   000000F8   ........           DC32     TIMER0_INTERVAL
   \   000000FC   00408F40           DC32     0x408f4000
    319          /****************************************************************************/
    320          /*Чтение массива коэффициентов из EEPROM,если не совпадает CRC запись в EEPROM*/
    321          /*всех значений по умолчанию*/
    322          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    323          void ReadEEPROMkoef_(void)
    324          {
   \                     ReadEEPROMkoef_:
   \   00000000   10402DE9           PUSH     {R4,LR}
    325            int irab;
    326            I2CMasKoefR_(); /*чтение массива коэфф*/
   \   00000004   ........           BL       I2CMasKoefR_
    327            CRC16(MasEEPROMKoef,15,0xFF,0);
   \   00000008   ........           LDR      R4,??DataTable21  ;; TABLTemperCORR
   \   0000000C   0030A0E3           MOV      R3,#+0
   \   00000010   FF20A0E3           MOV      R2,#+255
   \   00000014   0F10A0E3           MOV      R1,#+15
   \   00000018   800084E2           ADD      R0,R4,#+128
   \   0000001C   ........           _BLF     CRC16,??CRC16??rA
    328            if( (CRClo != MasEEPROMKoef[15]) || (CRChi != MasEEPROMKoef[16]) )
   \   00000020   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000024   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000028   8F10D4E5           LDRB     R1,[R4, #+143]
   \   0000002C   010050E1           CMP      R0,R1
   \   00000030   0400001A           BNE      ??ReadEEPROMkoef__0
   \   00000034   ........           LDR      R0,??DataTable40  ;; CRChi
   \   00000038   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000003C   9010D4E5           LDRB     R1,[R4, #+144]
   \   00000040   010050E1           CMP      R0,R1
   \   00000044   1A00000A           BEQ      ??ReadEEPROMkoef__1
    329            {
    330              //контрольная  сумма коэффициентов не совпадает- устанавливаем (инициализируем по умолчанию]
    331             /*байты 1,0 - KODADC   коэффициент усиления [по умолчание 1300]
    332                     3,2 - MINPOROG нижний порог [по умолчание 64]
    333                     5,4 - MAXPOROG верхний порог [по умолчание 4060]
    334                     6   - кол-во каналов биты 1,0 1024 =10 (2)
    335                     7   - код скорости обмена 115200бод = 1
    336                     9,8 - заводской номер [по умолчание 1]
    337                     11,10 - дата изготовления Год[07] , неделя[01]
    338                     12  - идентификационный код = 0
    339                     13  - интерфейсный адрес = 1
    340                     14  - номер версии =1
    341                     16,15 - CRC
    342                     20,19,18,17  - интервал измерения температуры в минутах 4 байта плав число
    343                     22,21 - CRC
    344                     */
    345             MasEEPROMKoef[1] = 0x05; //cт байт коэффициент усиления1300>>8;
   \                     ??ReadEEPROMkoef__0:
   \   00000048   0500A0E3           MOV      R0,#+5
   \   0000004C   8100C4E5           STRB     R0,[R4, #+129]
    346             MasEEPROMKoef[0] = 0x14;    //мл байт 1300
   \   00000050   1400A0E3           MOV      R0,#+20
   \   00000054   8000C4E5           STRB     R0,[R4, #+128]
    347          
    348             MasEEPROMKoef[3] = 0;      //cт байт нижний порог
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   8300C4E5           STRB     R0,[R4, #+131]
    349             MasEEPROMKoef[2] = 0x40;    //мл байт=64;
   \   00000060   4010A0E3           MOV      R1,#+64
   \   00000064   8210C4E5           STRB     R1,[R4, #+130]
    350          
    351             MasEEPROMKoef[5] = 0x0F; //cт байт верхний порог4060>>8;
   \   00000068   0F10A0E3           MOV      R1,#+15
   \   0000006C   8510C4E5           STRB     R1,[R4, #+133]
    352             MasEEPROMKoef[4] = 0xDC;    //мл байт 4060;
   \   00000070   DC10A0E3           MOV      R1,#+220
   \   00000074   8410C4E5           STRB     R1,[R4, #+132]
    353          
    354             MasEEPROMKoef[6] = 0x02;    //кол-во каналов биты 1,0 1024 =10 (2)
   \   00000078   0210A0E3           MOV      R1,#+2
   \   0000007C   8610C4E5           STRB     R1,[R4, #+134]
    355          
    356             MasEEPROMKoef[7] = 0x01;    //код скорости обмена 115200бод
   \   00000080   0110A0E3           MOV      R1,#+1
   \   00000084   8710C4E5           STRB     R1,[R4, #+135]
    357          
    358             MasEEPROMKoef[9] = 0x0;    //cт байт заводской номер
    359             MasEEPROMKoef[8] = 0x0;    //мл байт
   \   00000088   B808C4E1           STRH     R0,[R4, #+136]
    360          
    361             MasEEPROMKoef[11] = 0x07;  //cт байт -год
   \   0000008C   0700A0E3           MOV      R0,#+7
   \   00000090   8B00C4E5           STRB     R0,[R4, #+139]
    362             MasEEPROMKoef[10] = 0x01;    //мл байт  -неделя
   \   00000094   8A10C4E5           STRB     R1,[R4, #+138]
    363          
    364             MasEEPROMKoef[12] = 0x1;    //идентификационный код
   \   00000098   8C10C4E5           STRB     R1,[R4, #+140]
    365          
    366             MasEEPROMKoef[13] = 0x01;   //интерфейсный адрес
   \   0000009C   8D10C4E5           STRB     R1,[R4, #+141]
    367          
    368             MasEEPROMKoef[14] = 0x01;   //номер версии
   \   000000A0   8E10C4E5           STRB     R1,[R4, #+142]
    369          
    370             //ЗАПИСЬ КОЭФФИЦИЕНТОВ ПО УМОЛЧАНИЮ
    371            DELAYTACKT(irab,100006);
   \   000000A4   ........           LDR      R0,??DataTable29  ;; 0x186a6
   \                     ??ReadEEPROMkoef__2:
   \   000000A8   010050E2           SUBS     R0,R0,#+1
   \   000000AC   FDFFFF5A           BPL      ??ReadEEPROMkoef__2
    372            I2CMasKoefW_(); /*запись массива коэффициентов*/
   \   000000B0   ........           BL       I2CMasKoefW_
    373            } //end if( (CRClo != MasEEPRO......
    374            KODADC   = MasEEPROMKoef[1] << 8 | MasEEPROMKoef[0];  //коэффициент усиления тип short
   \                     ??ReadEEPROMkoef__1:
   \   000000B4   8100D4E5           LDRB     R0,[R4, #+129]
   \   000000B8   8010D4E5           LDRB     R1,[R4, #+128]
   \   000000BC   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000000C0   38109FE5           LDR      R1,??ReadEEPROMkoef__3  ;; KODADC
   \   000000C4   B000C1E1           STRH     R0,[R1, #+0]
    375            KODADCEEPROM = KODADC;
   \   000000C8   34109FE5           LDR      R1,??ReadEEPROMkoef__3+0x4  ;; KODADCEEPROM
   \   000000CC   B000C1E1           STRH     R0,[R1, #+0]
    376            MINPOROG = MasEEPROMKoef[3] << 8 | MasEEPROMKoef[2];  //нижний порог тип short
   \   000000D0   30009FE5           LDR      R0,??ReadEEPROMkoef__3+0x8  ;; MINPOROG
   \   000000D4   8310D4E5           LDRB     R1,[R4, #+131]
   \   000000D8   8220D4E5           LDRB     R2,[R4, #+130]
   \   000000DC   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000E0   B010C0E1           STRH     R1,[R0, #+0]
    377            MAXPOROG = MasEEPROMKoef[5] << 8 | MasEEPROMKoef[4];  //верхний порог тип short
   \   000000E4   20009FE5           LDR      R0,??ReadEEPROMkoef__3+0xC  ;; MAXPOROG
   \   000000E8   8510D4E5           LDRB     R1,[R4, #+133]
   \   000000EC   8420D4E5           LDRB     R2,[R4, #+132]
   \   000000F0   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000F4   B010C0E1           STRH     R1,[R0, #+0]
    378           }//end ReadEEPROMkoef
   \   000000F8   1040BDE8           POP      {R4,LR}
   \   000000FC   1EFF2FE1           BX       LR               ;; return
   \                     ??ReadEEPROMkoef__3:
   \   00000100   ........           DC32     KODADC
   \   00000104   ........           DC32     KODADCEEPROM
   \   00000108   ........           DC32     MINPOROG
   \   0000010C   ........           DC32     MAXPOROG
    379          /**************************************************************/
    380          /*запись полученного коэффициентов в EEPROM, его контр чтение */
    381          /* С деинициализацией I2C*/
    382          /*************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    383          unsigned  short  I2CKOEFF_( int IndMas)
    384          {
   \                     I2CKOEFF_:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    385          unsigned short NameKoef;
    386          int irab,i;
    387          if ((IndMas == 0) && (FLAG.temperCORR))
   \   00000008   60019FE5           LDR      R0,??I2CKOEFF__0  ;; COMMAND
   \   0000000C   0550D0E5           LDRB     R5,[R0, #+5]
   \   00000010   0470D0E5           LDRB     R7,[R0, #+4]
   \   00000014   ........           LDR      R6,??DataTable37  ;; TABLTemperCORR
   \   00000018   1700001A           BNE      ??I2CKOEFF__1
   \   0000001C   ........           LDR      R0,??DataTable38  ;; FLAG
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   800C10E3           TST      R0,#0x8000
   \   00000028   1300000A           BEQ      ??I2CKOEFF__1
    388                {//при темпер коррекции - сохраняем коэфф усиления за вычетом дельты тек температуры
    389                i = ((int)(TEMPERFLOAT+0.5)+10)<<1;  //нулевой индекс соотв -10 град,округление
   \   0000002C   40019FE5           LDR      R0,??I2CKOEFF__0+0x4  ;; TEMPERFLOAT
   \   00000030   000090E5           LDR      R0,[R0, #+0]
   \   00000034   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   C035A0E3           MOV      R3,#+805306368
   \   00000040   FE3683E3           ORR      R3,R3,#0xFE00000
   \   00000044   ........           _BLF     __dAdd,??__dAdd??rA
   \   00000048   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   0000004C   0A0080E2           ADD      R0,R0,#+10
   \   00000050   8000A0E1           LSL      R0,R0,#+1
    390                irab = (COMMAND[4]<<8 | COMMAND [5]) - (TABLTemperCORR[i]<< 8 | TABLTemperCORR[i+1]);
   \   00000054   071485E1           ORR      R1,R5,R7, LSL #+8
   \   00000058   0620D0E7           LDRB     R2,[R0, +R6]
   \   0000005C   060080E0           ADD      R0,R0,R6
   \   00000060   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000064   020480E1           ORR      R0,R0,R2, LSL #+8
   \   00000068   000041E0           SUB      R0,R1,R0
    391                MasEEPROMKoef[IndMas]   = irab;
   \   0000006C   8000C6E5           STRB     R0,[R6, #+128]
    392                MasEEPROMKoef[IndMas+1] = irab >> 8;
   \   00000070   4004A0E1           ASR      R0,R0,#+8
   \   00000074   8100C6E5           STRB     R0,[R6, #+129]
   \   00000078   020000EA           B        ??I2CKOEFF__2
    393                }
    394          else
    395          {
    396          MasEEPROMKoef[IndMas+1] = COMMAND[4];
   \                     ??I2CKOEFF__1:
   \   0000007C   060084E0           ADD      R0,R4,R6
   \   00000080   8170C0E5           STRB     R7,[R0, #+129]
    397          MasEEPROMKoef[IndMas]   = COMMAND[5];
   \   00000084   8050C0E5           STRB     R5,[R0, #+128]
    398          }
    399          
    400          InitialiseI2C(1,0); //инициализация для записи
   \                     ??I2CKOEFF__2:
   \   00000088   0010A0E3           MOV      R1,#+0
   \   0000008C   0100A0E3           MOV      R0,#+1
   \   00000090   ........           BL       InitialiseI2C
    401          I2CTransferByte(IndMas,2,MasEEPROMKoef+IndMas); //запись коэффиц
   \   00000094   060084E0           ADD      R0,R4,R6
   \   00000098   802080E2           ADD      R2,R0,#+128
   \   0000009C   0210A0E3           MOV      R1,#+2
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   FF0000E2           AND      R0,R0,#0xFF
   \   000000A8   ........           BL       I2CTransferByte
    402          
    403          while (lock == 1); //пока не записали нельзя считать CRC
   \                     ??I2CKOEFF__3:
   \   000000AC   A400D6E5           LDRB     R0,[R6, #+164]
   \   000000B0   010050E3           CMP      R0,#+1
   \   000000B4   FCFFFF0A           BEQ      ??I2CKOEFF__3
    404          
    405          CRC16(MasEEPROMKoef,15,0xFF,0);
   \   000000B8   0030A0E3           MOV      R3,#+0
   \   000000BC   FF20A0E3           MOV      R2,#+255
   \   000000C0   0F10A0E3           MOV      R1,#+15
   \   000000C4   800086E2           ADD      R0,R6,#+128
   \   000000C8   ........           _BLF     CRC16,??CRC16??rA
    406          
    407          MasEEPROMKoef[15] = CRClo;   //мл байт
   \   000000CC   ........           LDR      R0,??DataTable39  ;; CRClo
   \   000000D0   B000D0E1           LDRH     R0,[R0, #+0]
   \   000000D4   8F00C6E5           STRB     R0,[R6, #+143]
    408          MasEEPROMKoef[16] = CRChi;  //cт байт
   \   000000D8   ........           LDR      R0,??DataTable40  ;; CRChi
   \   000000DC   B000D0E1           LDRH     R0,[R0, #+0]
   \   000000E0   9000C6E5           STRB     R0,[R6, #+144]
    409          
    410          
    411          DELAYTACKT(irab,100006);
   \   000000E4   ........           LDR      R5,??DataTable29  ;; 0x186a6
   \   000000E8   0500A0E1           MOV      R0,R5
   \                     ??I2CKOEFF__4:
   \   000000EC   010050E2           SUBS     R0,R0,#+1
   \   000000F0   FDFFFF5A           BPL      ??I2CKOEFF__4
    412          I2CTransferByte(15,2,MasEEPROMKoef+15); //запись нового CRC
   \   000000F4   8F2086E2           ADD      R2,R6,#+143
   \   000000F8   0210A0E3           MOV      R1,#+2
   \   000000FC   0F00A0E3           MOV      R0,#+15
   \   00000100   ........           BL       I2CTransferByte
    413          
    414          DELAYTACKT(irab,100006);
   \                     ??I2CKOEFF__5:
   \   00000104   015055E2           SUBS     R5,R5,#+1
   \   00000108   FDFFFF5A           BPL      ??I2CKOEFF__5
    415          I2CTransferByte(IndMas,0);  //установка адреса данных на IndMas
   \   0000010C   0010A0E3           MOV      R1,#+0
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   FF0000E2           AND      R0,R0,#0xFF
   \   00000118   ........           BL       I2CTransferByte
    416          
    417          InitialiseI2C(1,1); //инициализация для ЧТЕНИЯ
   \   0000011C   0110A0E3           MOV      R1,#+1
   \   00000120   0100A0E1           MOV      R0,R1
   \   00000124   ........           BL       InitialiseI2C
    418          I2CTransferByte(IndMas,2,MasEEPROMKoef+IndMas); //контрольное чтение
   \   00000128   060084E0           ADD      R0,R4,R6
   \   0000012C   802080E2           ADD      R2,R0,#+128
   \   00000130   0210A0E3           MOV      R1,#+2
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   FF0000E2           AND      R0,R0,#0xFF
   \   0000013C   ........           BL       I2CTransferByte
    419          DeInitialiseI2C();
   \   00000140   ........           _BLF     DeInitialiseI2C,??DeInitialiseI2C??rA
    420          NameKoef  = MasEEPROMKoef[IndMas+1] << 8 | MasEEPROMKoef[IndMas];  //коэффициент
   \   00000144   060084E0           ADD      R0,R4,R6
   \   00000148   8100D0E5           LDRB     R0,[R0, #+129]
   \   0000014C   061084E0           ADD      R1,R4,R6
   \   00000150   8010D1E5           LDRB     R1,[R1, #+128]
   \   00000154   004481E1           ORR      R4,R1,R0, LSL #+8
    421          toCOMMAND2byte(4,NameKoef);     //коэффициент назад в команду
   \   00000158   0410A0E1           MOV      R1,R4
   \   0000015C   0400A0E3           MOV      R0,#+4
   \   00000160   ........           _BLF     toCOMMAND2byte,??toCOMMAND2byte??rA
    422          return NameKoef;
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   F040BDE8           POP      {R4-R7,LR}
   \   0000016C   1EFF2FE1           BX       LR               ;; return
   \                     ??I2CKOEFF__0:
   \   00000170   ........           DC32     COMMAND
   \   00000174   ........           DC32     TEMPERFLOAT
    423          }//end I2CKOEFF
    424          /*********************************************************/
    425          /*****************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    426          void ClearTABLtemperCORR (void)
    427          {
    428            int i;
    429          
    430            for (i=122; --i >=0;)
   \                     ClearTABLtemperCORR:
   \   00000000   7A00A0E3           MOV      R0,#+122
   \   00000004   ........           LDR      R1,??DataTable37  ;; TABLTemperCORR
   \   00000008   0020A0E3           MOV      R2,#+0
   \   0000000C   000000EA           B        ??ClearTABLtemperCORR_0
    431                        TABLTemperCORR[i] = 0;
   \                     ??ClearTABLtemperCORR_1:
   \   00000010   0120C0E7           STRB     R2,[R0, +R1]
   \                     ??ClearTABLtemperCORR_0:
   \   00000014   010050E2           SUBS     R0,R0,#+1
   \   00000018   FCFFFF5A           BPL      ??ClearTABLtemperCORR_1
    432          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    433          /****************************************************************************/
    434          /*Запись флага температурной коррекции в EEPROM -128+125 байт */
    435          /* С деинициализацией I2C*/
    436          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    437          void I2CTABLTempFlagW(void)
    438          {
   \                     I2CTABLTempFlagW:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    439              InitialiseI2C(1,0); //инициализация для записи
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   ........           BL       InitialiseI2C
    440          
    441              TABLTemperCORR[125]=0;
   \   00000010   ........           LDR      R4,??DataTable37  ;; TABLTemperCORR
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   7D00C4E5           STRB     R0,[R4, #+125]
    442              if (FLAG.temperCORR == 1)
   \   0000001C   ........           LDR      R5,??DataTable38  ;; FLAG
   \   00000020   000095E5           LDR      R0,[R5, #+0]
   \   00000024   800C00E2           AND      R0,R0,#0x8000
   \   00000028   A007A0E1           LSR      R0,R0,#+15
   \   0000002C   010050E3           CMP      R0,#+1
   \   00000030   0000001A           BNE      ??I2CTABLTempFlagW_0
    443                    TABLTemperCORR[125]=1;  //флаг темпер коррекции 1- разрешена
   \   00000034   7D00C4E5           STRB     R0,[R4, #+125]
    444          
    445              I2CTransferByte(128+125,1,TABLTemperCORR+125);
   \                     ??I2CTABLTempFlagW_0:
   \   00000038   7D2084E2           ADD      R2,R4,#+125
   \   0000003C   0110A0E3           MOV      R1,#+1
   \   00000040   FD00A0E3           MOV      R0,#+253
   \   00000044   ........           BL       I2CTransferByte
    446              while(lock == 1); //ждем записи
   \                     ??I2CTABLTempFlagW_1:
   \   00000048   A400D4E5           LDRB     R0,[R4, #+164]
   \   0000004C   010050E3           CMP      R0,#+1
   \   00000050   FCFFFF0A           BEQ      ??I2CTABLTempFlagW_1
    447          
    448              I2CTransferByte(0,0);  //установка адреса данных на 0 может быть ошибка АСК
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   ........           BL       I2CTransferByte
    449          
    450              I2CTransferByte(128+125,0);  //установка адреса данных флага
   \   00000060   0010A0E3           MOV      R1,#+0
   \   00000064   FD00A0E3           MOV      R0,#+253
   \   00000068   ........           BL       I2CTransferByte
    451              InitialiseI2C(1,1); //инициализация для чтения
   \   0000006C   0110A0E3           MOV      R1,#+1
   \   00000070   0100A0E1           MOV      R0,R1
   \   00000074   ........           BL       InitialiseI2C
    452              I2CTransferByte(128+125,1,TABLTemperCORR+125);
   \   00000078   7D2084E2           ADD      R2,R4,#+125
   \   0000007C   0110A0E3           MOV      R1,#+1
   \   00000080   FD00A0E3           MOV      R0,#+253
   \   00000084   ........           BL       I2CTransferByte
    453              DeInitialiseI2C();
   \   00000088   ........           _BLF     DeInitialiseI2C,??DeInitialiseI2C??rA
    454          
    455              FLAG.temperCORR = 0;
   \   0000008C   000095E5           LDR      R0,[R5, #+0]
   \   00000090   800CC0E3           BIC      R0,R0,#0x8000
   \   00000094   000085E5           STR      R0,[R5, #+0]
    456              if (TABLTemperCORR[125])
   \   00000098   7D00D4E5           LDRB     R0,[R4, #+125]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0200000A           BEQ      ??I2CTABLTempFlagW_2
    457                    FLAG.temperCORR = 1;  //флаг темпер коррекции - разрешена
   \   000000A4   000095E5           LDR      R0,[R5, #+0]
   \   000000A8   800C80E3           ORR      R0,R0,#0x8000
   \   000000AC   000085E5           STR      R0,[R5, #+0]
    458          }
   \                     ??I2CTABLTempFlagW_2:
   \   000000B0   3040BDE8           POP      {R4,R5,LR}
   \   000000B4   1EFF2FE1           BX       LR               ;; return
    459          /****************************************************************************/
    460          /*Чтение массива температурной коррекции + CRC и флага в EEPROM -125 байт */
    461          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    462          void I2CTABLTempR(void)
    463          {
   \                     I2CTABLTempR:
   \   00000000   10402DE9           PUSH     {R4,LR}
    464            InitialiseI2C(1,0);     //инициализация для записи
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   ........           BL       InitialiseI2C
    465            I2CTransferByte(128,0);  //установка адреса данных таблицы = 128
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   8000A0E3           MOV      R0,#+128
   \   00000018   ........           BL       I2CTransferByte
    466            InitialiseI2C(1,1); //инициализация   для чтения
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   ........           BL       InitialiseI2C
    467            I2CTransferByte(128,126,TABLTemperCORR);//начало таблицы адрес 128!!!
   \   00000028   ........           LDR      R4,??DataTable37  ;; TABLTemperCORR
   \   0000002C   0420A0E1           MOV      R2,R4
   \   00000030   7E10A0E3           MOV      R1,#+126
   \   00000034   8000A0E3           MOV      R0,#+128
   \   00000038   ........           BL       I2CTransferByte
    468            while(lock == 1); //ждем чтения
   \                     ??I2CTABLTempR_0:
   \   0000003C   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000040   010050E3           CMP      R0,#+1
   \   00000044   FCFFFF0A           BEQ      ??I2CTABLTempR_0
    469          }
   \   00000048   1040BDE8           POP      {R4,LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    470          /****************************************************************************/
    471          /*Запись массива температурной коррекции + CRC и флага в EEPROM -125 байт */
    472          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    473          void I2CTABLTempW_(void)
    474          {
   \                     I2CTABLTempW_:
   \   00000000   10402DE9           PUSH     {R4,LR}
    475              CRC16(TABLTemperCORR,122,0xFF,0);//CRC СЧИТАЕМ ТОЛЬКО ДЛЯ ДЕЛЬ
   \   00000004   ........           LDR      R4,??DataTable37  ;; TABLTemperCORR
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   FF20A0E3           MOV      R2,#+255
   \   00000010   7A10A0E3           MOV      R1,#+122
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           _BLF     CRC16,??CRC16??rA
    476              TABLTemperCORR[122] = CRClo;
   \   0000001C   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000020   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000024   7A00C4E5           STRB     R0,[R4, #+122]
    477              TABLTemperCORR[123] = CRChi;
   \   00000028   ........           LDR      R0,??DataTable40  ;; CRChi
   \   0000002C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000030   7B00C4E5           STRB     R0,[R4, #+123]
    478              InitialiseI2C(1,0); //инициализация для записи
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   ........           BL       InitialiseI2C
    479              I2CTransferByte(128,126,TABLTemperCORR);
   \   00000040   0420A0E1           MOV      R2,R4
   \   00000044   7E10A0E3           MOV      R1,#+126
   \   00000048   8000A0E3           MOV      R0,#+128
   \   0000004C   ........           BL       I2CTransferByte
    480              while(lock == 1); //ждем записи
   \                     ??I2CTABLTempW__0:
   \   00000050   A400D4E5           LDRB     R0,[R4, #+164]
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   FCFFFF0A           BEQ      ??I2CTABLTempW__0
    481          }
   \   0000005C   1040BDE8           POP      {R4,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return
    482          /****************************************************************************/
    483          /*Чтение массива коэффициентов температурной коррекции  из EEPROM,*/
    484          /*если не совпадает CRC запись в EEPROM cтандартных значений =0 */
    485          /****************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    486          void ReadTABLtemper_(void)
    487          {
   \                     ReadTABLtemper_:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    488            I2CTABLTempR(); //чтение всего массива + CRC + флаг
   \   00000004   ........           BL       I2CTABLTempR
    489            CRC16(TABLTemperCORR,122,0xFF,0);
   \   00000008   ........           LDR      R4,??DataTable37  ;; TABLTemperCORR
   \   0000000C   0030A0E3           MOV      R3,#+0
   \   00000010   FF20A0E3           MOV      R2,#+255
   \   00000014   7A10A0E3           MOV      R1,#+122
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           _BLF     CRC16,??CRC16??rA
    490            if( (CRClo != TABLTemperCORR[122]) || (CRChi != TABLTemperCORR[123]) )
   \   00000020   ........           LDR      R5,??DataTable38  ;; FLAG
   \   00000024   ........           LDR      R0,??DataTable39  ;; CRClo
   \   00000028   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000002C   7A10D4E5           LDRB     R1,[R4, #+122]
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   0400001A           BNE      ??ReadTABLtemper__0
   \   00000038   ........           LDR      R0,??DataTable40  ;; CRChi
   \   0000003C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000040   7B10D4E5           LDRB     R1,[R4, #+123]
   \   00000044   010050E1           CMP      R0,R1
   \   00000048   0600000A           BEQ      ??ReadTABLtemper__1
    491            {
    492              ClearTABLtemperCORR();  // чистим всю таблицу
   \                     ??ReadTABLtemper__0:
   \   0000004C   ........           BL       ClearTABLtemperCORR
    493              FLAG.ErrtempTABL = 1; //флаг ошибка CRC табл темп корр - при 1-й инициализации
   \   00000050   000095E5           LDR      R0,[R5, #+0]
   \   00000054   040080E3           ORR      R0,R0,#0x4
   \   00000058   000085E5           STR      R0,[R5, #+0]
    494              TABLTemperCORR[125] = 1; //флаг темпер коррекции - 0- запрещена 1 - разрешен
   \   0000005C   0100A0E3           MOV      R0,#+1
   \   00000060   7D00C4E5           STRB     R0,[R4, #+125]
    495              I2CTABLTempW_();
   \   00000064   ........           BL       I2CTABLTempW_
    496          }
    497            FLAG.temperCORR = 0;
   \                     ??ReadTABLtemper__1:
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   800CC0E3           BIC      R0,R0,#0x8000
   \   00000070   000085E5           STR      R0,[R5, #+0]
    498            if (TABLTemperCORR[125])
   \   00000074   7D00D4E5           LDRB     R0,[R4, #+125]
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0200000A           BEQ      ??ReadTABLtemper__2
    499                    FLAG.temperCORR = 1;  //флаг темпер коррекции - разрешена
   \   00000080   000095E5           LDR      R0,[R5, #+0]
   \   00000084   800C80E3           ORR      R0,R0,#0x8000
   \   00000088   000085E5           STR      R0,[R5, #+0]
    500          }//end ReadTABLtemper
   \                     ??ReadTABLtemper__2:
   \   0000008C   3040BDE8           POP      {R4,R5,LR}
   \   00000090   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     TABLTemperCORR

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   A6860100           DC32     0x186a6

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   ........           DC32     TABLTemperCORR

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   ........           DC32     FLAG

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   ........           DC32     CRClo

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   ........           DC32     CRChi
    501          /****************************************************************************/

   Maximum stack usage in bytes:

     Function                  CSTACK
     --------                  ------
     ClearTABLtemperCORR           0
     I2CInterruptR                20
     I2CInterruptW                16
     I2CIntevarTemperR             8
     I2CIntevarTemperW_            8
     I2CKOEFF_                    20
     I2CMasKoefR_                  8
     I2CMasKoefW_                  8
     I2CStopBit                    0
     I2CTABLTempFlagW             12
     I2CTABLTempR                  8
     I2CTABLTempW_                 8
     I2CTransferByte               0
     InitialiseI2C                 4
     ReadEEPROMIntervalTemper_    12
     ReadEEPROMkoef_               8
     ReadTABLtemper_              12


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_PCONP                     4
     _A_VICIntEnable              4
     VICVectAddr3                 4
     _A_VICVectCntl3              4
     _A_PINSEL0                   4
     _A_I2CONSET                  4
     _A_I2STAT                    4
     _A_I2DAT                     4
     _A_I2SCLH                    4
     _A_I2SCLL                    4
     _A_I2CONCLR                  4
     TABLTemperCORR             167
     InitialiseI2C              220
     I2CStopBit                  32
     I2CInterruptW              300
     I2CInterruptR              300
     I2CTransferByte            116
     I2CMasKoefW_               100
     I2CMasKoefR_                80
     I2CIntevarTemperR           80
     I2CIntevarTemperW_         128
     ReadEEPROMIntervalTemper_  256
     ReadEEPROMkoef_            272
     I2CKOEFF_                  376
     ClearTABLtemperCORR         32
     I2CTABLTempFlagW           184
     I2CTABLTempR                80
     I2CTABLTempW_              100
     ReadTABLtemper_            148
     ??DataTable21                4
     ??DataTable29                4
     ??DataTable37                4
     ??DataTable38                4
     ??DataTable39                4
     ??DataTable40                4
      Others                    176

 
 2 992 bytes in segment CODE
    44 bytes in segment DATA_AN
   167 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 2 828 bytes of CODE memory (+ 176 bytes shared)
   167 bytes of DATA memory (+  44 bytes shared)

Errors: none
Warnings: none
